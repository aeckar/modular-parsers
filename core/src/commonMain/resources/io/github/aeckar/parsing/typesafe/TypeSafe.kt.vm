@file:Suppress("TrailingComma")
package io.github.aeckar.parsing.typesafe
#define($lowercaseIdentifier)#if($identifier == "Junction")junction#else#evaluate("sequence")#end#end
#define($fragileUnsafeCast)fragileUnsafeCast<${identifier}Token$n<#typeArguments("T" "")>>()#end
#define($tokenReceiver)Token<$identifier$n<#typeArguments('T' '')>>#end
#define($typeSafeTuple)TypeSafeTuple$n<#typeArguments("Token<T" ">")>#end
#macro(classTypeArguments $letter $suffix)#foreach($_ in [1..$n])$letter$foreach.count$suffix, #end#end
#macro(typeArguments $letter $suffix)#foreach($_ in [1..$n])$letter$foreach.count$suffix, #end#end
#macro(forEachOrdinal $template)#foreach($ordinal in $ordinals)#if($foreach.count > $n)#break#end#evaluate($template)#end#end

import io.github.aeckar.parsing.NamedSymbol
import io.github.aeckar.parsing.Symbol
import io.github.aeckar.parsing.Token
import io.github.aeckar.parsing.$identifier
import io.github.aeckar.parsing.utils.fragileUnsafeCast

import kotlin.reflect.KProperty

/**
* A [$lowercaseIdentifier symbol][$identifier] with $n components.
*/
public class $identifier$n<#classTypeArguments("S" " : Symbol")> internal constructor(
    actual: $identifier
) : TypeSafe$identifier<$identifier$n<#typeArguments("S" "")>>(actual) {
    override fun getValue(thisRef: Any?, property: KProperty<*>): NamedSymbol<$identifier$n<#typeArguments("S" "")>> {
        return NamedSymbol(property.name, this)
    }
}

/**
 * A token emitted by a [$lowercaseIdentifier symbol][$identifier] with $n components.
 */
@PublishedApi
internal class ${identifier}Token$n<#classTypeArguments("T" " : Symbol")>(
    symbol: $identifier$n<#typeArguments("T" "")>,
    substring: String,
    val #if($identifier == "Junction")match: Token<*>,
    override val matchOrdinal: Int#else matches: $typeSafeTuple#end
) : Token<$identifier$n<#typeArguments("T" "")>>(symbol, substring)#if($identifier == "Junction"), JunctionToken#end

#if($identifier == "Junction")
#forEachOrdinal("    public inline fun <#classTypeArguments('T' ' : Symbol')> ${tokenReceiver}.on$ordinal(action: Token<T$foreach.count>.() -> Unit): Unit = action(${fragileUnsafeCast}.match)
")
#else
/**
 * A type-safe tuple containing $n elements.
 */
public class TypeSafeTuple$n<#classTypeArguments("T" "")> internal constructor(
#forEachOrdinal("    public var $ordinal: T$foreach.count,
")
) {
#forEachOrdinal("    public operator fun component${foreach.count}(): T$foreach.count = $ordinal
")
}

public val <#classTypeArguments('T' ' : Symbol')> ${tokenReceiver}.matches: $typeSafeTuple get() = ${fragileUnsafeCast}.matches

#forEachOrdinal("public inline fun <#classTypeArguments('T' ' : Symbol')> $tokenReceiver.$ordinal(action: Token<T$foreach.count>.() -> Unit): Unit = action(${fragileUnsafeCast}.matches.$ordinal)
")
#end