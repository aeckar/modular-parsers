@file:Suppress("TrailingComma", "SpellCheckingInspection")
package io.github.aeckar.parsing.typesafe
#define($lowercaseIdentifier)#if($identifier == "Junction")junction#else#evaluate("sequence")#end#end
#define($fragileUnsafeCast)fragileUnsafeCast<${identifier}Token$n<#typeArguments("T" "")>>()#end
#define($tokenReceiver)Token<$identifier$n<#typeArguments("T" "")>>#end
#define($typeSafeTuple)TypeSafeTuple$n<#typeArguments("Token<T" ">")>#end
#macro(classTypeArguments $letter $suffix)#foreach($_ in [1..$n])$letter$foreach.count$suffix, #end#end
#macro(typeArguments $letter $suffix)#foreach($_ in [1..$n])$letter$foreach.count$suffix, #end#end
#macro(forEachOrdinal $template)#foreach($ordinal in $ordinals)#if($foreach.count > $n)#break#end#evaluate($template)#end#end
#macro(addToUntyped $varName $suffix)untyped.apply { components += ${varName}$nPlus1$suffix }.unsafeCast()#end
#set($nPlus1 = $n + 1)

import io.github.aeckar.parsing.Symbol
import io.github.aeckar.parsing.Token
import io.github.aeckar.parsing.$identifier
import io.github.aeckar.parsing.Text
import io.github.aeckar.parsing.utils.fragileUnsafeCast
import io.github.aeckar.parsing.utils.unsafeCast

/**
* A [$lowercaseIdentifier symbol][$identifier] with $n components.
*/
public class $identifier$n<#classTypeArguments("S" " : Symbol")> internal constructor(
    untyped: $identifier<$identifier$n<#typeArguments("S" "")>>
) : TypeSafe$identifier<$identifier$n<#typeArguments("S" "")>>(untyped) {
#if($identifier == "Junction")
    /**
     * Adds the text as an option in this junction.
     */
    public infix fun or(option$nPlus1: Char): Junction$nPlus1<#typeArguments("S" "")Text> = Junction$nPlus1(#addToUntyped("Text(option" ")"))

    /**
     * Adds the symbol as an option in this junction.
     */
    public infix fun <S$nPlus1 : Symbol> or(option$nPlus1: S$nPlus1): Junction$nPlus1<#typeArguments("S" "")S$nPlus1> = Junction$nPlus1(#addToUntyped("option" ""))
#else
#if($foreach.count != $typeSafeCount)    /**
     * Adds the text to this sequence.
     */
    public operator fun plus(query$nPlus1: Char): Sequence$nPlus1<#typeArguments("S" "")Text> = Sequence$nPlus1(#addToUntyped("Text(query" ")"))

    /**
     * Adds the symbol to this sequence
     */
    public operator fun <S$nPlus1 : Symbol> plus(query$nPlus1: S$nPlus1): Sequence$nPlus1<#typeArguments("S" "")S$nPlus1> = Sequence$nPlus1(#addToUntyped("query" ""))
#end#end
}

/**
 * A token emitted by a [$lowercaseIdentifier symbol][$identifier] with $n components.
 */
@PublishedApi
internal class ${identifier}Token$n<#classTypeArguments("T" " : Symbol")>(
    symbol: $identifier$n<#typeArguments("T" "")>,
    substring: String,
    val #if($identifier == "Junction")match: Token<*>,
    override val matchOrdinal: Int#else#evaluate("matches"): $typeSafeTuple#end
) : Token<$identifier$n<#typeArguments("T" "")>>(symbol, substring)#if($identifier == "Junction"), JunctionToken#end

#if($identifier == "Junction")
#forEachOrdinal(
"/*
 * If the $ordinal option is matched, invokes the supplied lambda, else does nothing.
 */
public inline fun <#classTypeArguments('T' ' : Symbol')> ${tokenReceiver}.on$ordinal(action: Token<T$foreach.count>.() -> Unit) {
    val token = ${fragileUnsafeCast}
    if (token.matchOrdinal == $foreach.count) {
        action(token.match.unsafeCast())
    }
}
")
#else
/**
 * A type-safe tuple containing $n elements.
 */
public class TypeSafeTuple$n<#classTypeArguments("T" "")> internal constructor(
#forEachOrdinal(
"    /**
     * The $ordinal element in this tuple.
     */
    public var $ordinal: T$foreach.count,

")
) {
#forEachOrdinal(
"    /**
     * Returns the [$ordinal] element.
     */
    public operator fun component${foreach.count}(): T$foreach.count = $ordinal

")
}

/**
 * A type-safe tuple of the matches made by the symbol emitting this token.
 */
public val <#classTypeArguments('T' ' : Symbol')> ${tokenReceiver}.matches: $typeSafeTuple get() = ${fragileUnsafeCast}.matches

#forEachOrdinal(
"/**
 * The $ordinal match made by the symbol emitting this token.
 */
public inline fun <#classTypeArguments('T' ' : Symbol')> $tokenReceiver.$ordinal(action: Token<T$foreach.count>.() -> Unit): Unit = action(${fragileUnsafeCast}.matches.$ordinal)

")#end